name: Deploy 3-Tier App to EKS

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-northeast-2
  ECR_BACKEND_REPO: back
  ECR_FRONTEND_REPO: front
  EKS_CLUSTER_NAME: my-eks-cluster

permissions:
  id-token: write
  contents: read

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: project1/backend/package.json
    
    - name: Install backend dependencies
      run: |
        cd project1/backend
        npm install
    
    - name: Run backend tests
      run: |
        cd project1/backend
        npm test

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}
        mask-aws-account-id: false
    
    - name: Verify AWS credentials
      run: |
        echo "=== AWS 자격 증명 확인 ==="
        aws sts get-caller-identity
        echo "AWS Region: $AWS_REGION"
        echo "Assumed Role: $(aws sts get-caller-identity --query Arn --output text)"
    
    - name: Login to ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        registry-type: private
    
    - name: Set ECR registry
      id: ecr-registry
      run: |
        echo "registry=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_OUTPUT
        echo "ECR Registry: ${{ steps.login-ecr.outputs.registry }}"
    
    - name: Create ECR repositories if they don't exist
      run: |
        # Create backend repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_BACKEND_REPO }} --region ${{ env.AWS_REGION }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_BACKEND_REPO }} --region ${{ env.AWS_REGION }}
        
        # Create frontend repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_FRONTEND_REPO }} --region ${{ env.AWS_REGION }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_FRONTEND_REPO }} --region ${{ env.AWS_REGION }}
    
    - name: Build and push Backend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd project1/backend
        
        # Build image
        docker build -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest .
        
        # Push images
        docker push $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest
        
        echo "Backend image pushed: $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG"
    
    - name: Build and push Frontend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd project1/frontend
        
        # Build image
        docker build -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest .
        
        # Push images
        docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest
        
        echo "Frontend image pushed: $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG"
    
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME }}
    
    - name: Deploy to EKS
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Create temporary deployment files with updated image tags
        cp project1/backend-deployment.yaml backend-deployment-temp.yaml
        cp project1/frontend-deployment.yaml frontend-deployment-temp.yaml
        
        # Update image tags in deployment files
        sed -i "s|101553892293.dkr.ecr.ap-northeast-2.amazonaws.com/back:latest|$ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG|g" backend-deployment-temp.yaml
        sed -i "s|101553892293.dkr.ecr.ap-northeast-2.amazonaws.com/front:latest|$ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG|g" frontend-deployment-temp.yaml
        
        # Apply Kubernetes manifests
        kubectl apply -f project1/database-config.yaml
        kubectl apply -f backend-deployment-temp.yaml
        kubectl apply -f frontend-deployment-temp.yaml
        kubectl apply -f project1/ingress.yaml
        
        # Clean up temporary files
        rm backend-deployment-temp.yaml frontend-deployment-temp.yaml
        
        # Wait for deployments to be ready
        kubectl rollout status deployment/backend --timeout=300s
        kubectl rollout status deployment/frontend --timeout=300s
    
    - name: Verify deployment
      run: |
        kubectl get pods -l app=backend
        kubectl get pods -l app=frontend
        kubectl get svc
        kubectl get ingress
        
    - name: Run smoke tests
      run: |
        # Get the load balancer URL
        LB_URL=$(kubectl get ingress app-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        echo "Testing application at: http://$LB_URL"
        
        # Wait for load balancer to be ready
        sleep 60
        
        # Test backend health
        curl -f "http://$LB_URL/api/health" || echo "Backend health check failed"
        
        # Test frontend
        curl -f "http://$LB_URL/" || echo "Frontend check failed"
        
