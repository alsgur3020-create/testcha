name: Deploy 3-Tier App to EKS

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  AWS_REGION: ap-northeast-2
  ECR_BACKEND_REPO: back
  ECR_FRONTEND_REPO: front

permissions:
  id-token: write
  contents: read

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
        cache-dependency-path: project1/backend/package.json
    
    - name: Install backend dependencies
      run: |
        cd project1/backend
        npm install
    
    - name: Run backend tests
      run: |
        cd project1/backend
        npm test

  build-and-deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Configure AWS credentials using OIDC
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        role-session-name: GitHubActions-${{ github.run_id }}
        aws-region: ${{ env.AWS_REGION }}
        mask-aws-account-id: false
    
    - name: Verify AWS credentials
      run: |
        echo "=== AWS 자격 증명 확인 ==="
        aws sts get-caller-identity
        echo "AWS Region: $AWS_REGION"
        echo "Assumed Role: $(aws sts get-caller-identity --query Arn --output text)"
    
    - name: Login to ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      with:
        registry-type: private
    
    - name: Set ECR registry
      id: ecr-registry
      run: |
        echo "registry=${{ steps.login-ecr.outputs.registry }}" >> $GITHUB_OUTPUT
        echo "ECR Registry: ${{ steps.login-ecr.outputs.registry }}"
    
    - name: Create ECR repositories if they don't exist
      run: |
        # Create backend repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_BACKEND_REPO }} --region ${{ env.AWS_REGION }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_BACKEND_REPO }} --region ${{ env.AWS_REGION }}
        
        # Create frontend repository
        aws ecr describe-repositories --repository-names ${{ env.ECR_FRONTEND_REPO }} --region ${{ env.AWS_REGION }} || \
        aws ecr create-repository --repository-name ${{ env.ECR_FRONTEND_REPO }} --region ${{ env.AWS_REGION }}
    
    - name: Build and push Backend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd project1/backend
        
        # Build image
        docker build -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest .
        
        # Push images
        docker push $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:latest
        
        echo "Backend image pushed: $ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG"
    
    - name: Build and push Frontend image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cd project1/frontend
        
        # Build image
        docker build -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest .
        
        # Push images
        docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:latest
        
        echo "Frontend image pushed: $ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG"
    
    - name: Check EKS cluster availability
      id: check-eks
      run: |
        echo "=== EKS 클러스터 확인 ==="
        if [ -z "${{ secrets.EKS_CLUSTER_NAME }}" ]; then
          echo "⚠️  EKS_CLUSTER_NAME Secret이 설정되지 않았습니다."
          echo "EKS 배포를 건너뜁니다."
          echo "skip_eks=true" >> $GITHUB_OUTPUT
        else
          echo "EKS 클러스터 이름: ${{ secrets.EKS_CLUSTER_NAME }}"
          if aws eks describe-cluster --region ${{ env.AWS_REGION }} --name "${{ secrets.EKS_CLUSTER_NAME }}" > /dev/null 2>&1; then
            echo "✅ EKS 클러스터를 찾았습니다."
            echo "skip_eks=false" >> $GITHUB_OUTPUT
          else
            echo "❌ EKS 클러스터를 찾을 수 없습니다: ${{ secrets.EKS_CLUSTER_NAME }}"
            echo "사용 가능한 클러스터 목록:"
            aws eks list-clusters --region ${{ env.AWS_REGION }} || echo "클러스터 목록을 가져올 수 없습니다."
            echo "skip_eks=true" >> $GITHUB_OUTPUT
          fi
        fi
    
    - name: Update kubeconfig
      if: steps.check-eks.outputs.skip_eks == 'false'
      run: |
        echo "=== EKS 클러스터 연결 ==="
        
        # 현재 AWS 자격 증명 확인
        aws sts get-caller-identity
        
        # kubeconfig 업데이트 (더 상세한 옵션 포함)
        aws eks update-kubeconfig \
          --region ${{ env.AWS_REGION }} \
          --name "${{ secrets.EKS_CLUSTER_NAME }}" \
          --alias github-actions \
          --verbose
        
        # kubeconfig 파일 확인
        echo "=== kubeconfig 내용 확인 ==="
        kubectl config view --minify
        
        # 클러스터 연결 테스트
        echo "=== 클러스터 연결 테스트 ==="
        kubectl version --client
        kubectl cluster-info --request-timeout=30s || echo "클러스터 정보 조회 실패"
        
        echo "✅ kubeconfig 설정 완료"
    
    - name: Deploy to EKS
      if: steps.check-eks.outputs.skip_eks == 'false'
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "=== 배포 파일 준비 ==="
        # Create temporary deployment files with updated image tags
        cp project1/backend-deployment.yaml backend-deployment-temp.yaml
        cp project1/frontend-deployment.yaml frontend-deployment-temp.yaml
        
        # Update image tags in deployment files
        sed -i "s|101553892293.dkr.ecr.ap-northeast-2.amazonaws.com/back:latest|$ECR_REGISTRY/${{ env.ECR_BACKEND_REPO }}:$IMAGE_TAG|g" backend-deployment-temp.yaml
        sed -i "s|101553892293.dkr.ecr.ap-northeast-2.amazonaws.com/front:latest|$ECR_REGISTRY/${{ env.ECR_FRONTEND_REPO }}:$IMAGE_TAG|g" frontend-deployment-temp.yaml
        
        echo "=== 배포 파일 내용 확인 ==="
        echo "Backend 이미지: $(grep 'image:' backend-deployment-temp.yaml)"
        echo "Frontend 이미지: $(grep 'image:' frontend-deployment-temp.yaml)"
        
        echo "=== Kubernetes 리소스 배포 ==="
        
        # 각 리소스를 개별적으로 배포하고 에러 처리
        echo "1. Database config 배포..."
        if ! kubectl apply -f project1/database-config.yaml --validate=false --dry-run=server; then
          echo "⚠️  Database config dry-run 실패, 강제 적용 시도..."
          kubectl apply -f project1/database-config.yaml --validate=false --force || echo "Database config 배포 실패"
        else
          kubectl apply -f project1/database-config.yaml --validate=false
        fi
        
        echo "2. Backend deployment 배포..."
        if ! kubectl apply -f backend-deployment-temp.yaml --validate=false --dry-run=server; then
          echo "⚠️  Backend deployment dry-run 실패, 강제 적용 시도..."
          kubectl apply -f backend-deployment-temp.yaml --validate=false --force || echo "Backend deployment 배포 실패"
        else
          kubectl apply -f backend-deployment-temp.yaml --validate=false
        fi
        
        echo "3. Frontend deployment 배포..."
        if ! kubectl apply -f frontend-deployment-temp.yaml --validate=false --dry-run=server; then
          echo "⚠️  Frontend deployment dry-run 실패, 강제 적용 시도..."
          kubectl apply -f frontend-deployment-temp.yaml --validate=false --force || echo "Frontend deployment 배포 실패"
        else
          kubectl apply -f frontend-deployment-temp.yaml --validate=false
        fi
        
        echo "4. Ingress 배포..."
        if ! kubectl apply -f project1/ingress.yaml --validate=false --dry-run=server; then
          echo "⚠️  Ingress dry-run 실패, 강제 적용 시도..."
          kubectl apply -f project1/ingress.yaml --validate=false --force || echo "Ingress 배포 실패"
        else
          kubectl apply -f project1/ingress.yaml --validate=false
        fi
        
        # Clean up temporary files
        rm -f backend-deployment-temp.yaml frontend-deployment-temp.yaml
        
        echo "=== 배포 상태 확인 ==="
        kubectl get deployments
        kubectl get pods
        
        # Wait for deployments to be ready (더 관대한 타임아웃)
        echo "=== 배포 완료 대기 ==="
        kubectl rollout status deployment/backend --timeout=600s || echo "Backend 배포 타임아웃"
        kubectl rollout status deployment/frontend --timeout=600s || echo "Frontend 배포 타임아웃"
    
    - name: Verify deployment
      if: steps.check-eks.outputs.skip_eks == 'false'
      run: |
        kubectl get pods -l app=backend
        kubectl get pods -l app=frontend
        kubectl get svc
        kubectl get ingress
        
    - name: Run smoke tests
      if: steps.check-eks.outputs.skip_eks == 'false'
      run: |
        # Get the load balancer URL
        LB_URL=$(kubectl get ingress app-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        echo "Testing application at: http://$LB_URL"
        
        # Wait for load balancer to be ready
        sleep 60
        
        # Test backend health
        curl -f "http://$LB_URL/api/health" || echo "Backend health check failed"
        
        # Test frontend
        curl -f "http://$LB_URL/" || echo "Frontend check failed"
    
    - name: Summary
      run: |
        echo "=== 배포 요약 ==="
        echo "✅ Docker 이미지 빌드 및 ECR 푸시 완료"
        if [ "${{ steps.check-eks.outputs.skip_eks }}" == "true" ]; then
          echo "⚠️  EKS 배포 건너뜀 (클러스터 미설정 또는 미존재)"
          echo ""
          echo "EKS 배포를 위해 다음을 확인하세요:"
          echo "1. EKS 클러스터가 생성되어 있는지 확인"
          echo "2. GitHub Secrets에 EKS_CLUSTER_NAME 설정"
          echo "3. IAM Role에 EKS 권한 추가"
        else
          echo "✅ EKS 배포 완료"
        fi
        
